# Airspace Link Hackery

This is the code to generate the **C** bindings for the rust based DJI log parser.

## How is this used?

We generate the **C** bindings for the **rust** library and then embed it into our Golang [flight management service](https://github.com/airspace-link-inc/flight-management). Embedding the artifacts directly into the repository.

## Table of Contents

1. `src/lib.rs`: The main file where all the glue code for the **rust** -> **C** bindings happen.
1. `cbindgen.toml`: Configuration file that specifies which **rust** functions should be included in the generated **C** header file.
1. `build.rs`: This script generates the C header file. It uses `cbindgen` to scan your entire crate and generate the **C bindings** based on the configuration in `cbindgen.toml`.

## Build Process

1. Determine the architecture(s) you need.
   - `x86_64-unknown-linux-gnu`: What you will need for the deployment, whenever there is a modifications make sure this gets built.
   - `aarch64-unknown-linux-gnu`:: Required to run [flight-management](https://github.com/airspace-link-inc/flight-management) in a docker container on MacOS.
1. Run the appropriate build command from the `Makefile`. Example:
   ```sh
   make x86_64-unknown-linux-gnu
   ```
1. Copy the necessary artifacts over to the `flight management` repository. I will assume that both this and `flight-management` have the same parent directory. **IMPORTANT!!! Rename the libdji_log_parser_c.a file to libdji_log_parser.a**. If you don't rename the file `flight-management` wont compile, we have the c bindings determined off a file with that exact name. I have done so in the following example:
   ```sh
   cp ./bin/x86_64-unknown-linux-gnu/libdji_log_parser_c.a ../flight-management/fileparser/dji/lib/x86_64-unknown-linux-gnu/release/libdji_log_parser.a
   cp ./dji-log-parser-c/include/dji-log-parser-c.h ../flight-management/fileparser/dji/include/dji-log-parser.h
   ```
1. Nothing you're done :)

## Output

After the build process is successfully run there are some artifacts that get generated:

1. `dji-log-parser.h`: **C** header file that gets generated by the `build.rs` file.
1. `libdji_log_parser_c.a`: The binary-y-goodness that we need to embed in our app. Note that this file is for a specific architecture. As long as you build through the `Makefile` commands you do not need to worry about this.

## Edan Cain's Original README

I extended this work and I provide an explanation of the automation process of
creating a C-compatible interface of the RUST library for use by other
languages.
(nb: original implementation was manual creation of the header file. Now the
process is automated as is explained below)

The build.rs file works in conjunction with the c_api.rs file to create the
dji-log-parser.h file.
. build.rs: is a special RUST file that runs before the main compilation.
It's purpose is to generate the C header file automatically.
: it determines the crate directory and package name.
: it sets up the output path for the header file.
: it uses the cbindgen library to generate C bindings from the RUST code.

The c_api.rs file contains the RUST functions that will be exposed to C.
: functions marked with #[no_mangle] and pub extern "C" are made available to C.
: these function use C-compatible types (like c_char instead of RUST's str).

How it works:
. when the code is run with "cargo build", the build.rs script is executed first.
. it looks for functions marked with #[no_mangle] and pub extern "C".
. for each of these functions, it generates a corresponding C function declaration in the header file.

Resulting dji-log-parser.h file.
; this file is the interface that other languages use to interact with the RUST library.
: it declares the functions that are implemented in RUST but callable from C.

The build.rs automates the process of creating a C-compatible interface for
the RUST library. It ensures that the header
file always matches the actual implementation in the RUST code, in order to
reduce the chance of compile error from manual
updates.

To use the RUST library ("libdji_log_parser.a") from other languages, include
the generated dji-log-parser.h and link against library.

Golang example:

```golang
package mypackage

/*
#cgo LDFLAGS: -L${SRCDIR}/../target/release -ldji_log_parser
#cgo CFLAGS: -I${SRCDIR}/../dji-log-parser/include
#include "dji-log-parser.h"
#include <stdlib.h>
*/

import "C"

<further imports here>
type GeoJSON struct {
Type     string    `json:"type"`
Features []Feature `json:"features"`
}

type Feature struct {
    Type       string     `json:"type"`
    Geometry   Geometry   `json:"geometry"`
    Properties Properties `json:"properties"`
}

type Geometry struct {
    Type        string    `json:"type"`
    Coordinates []float64 `json:"coordinates"`
}

type Properties struct {
    Time   string  `json:"time"`
    Height float64 `json:"height"`
    Speed  float64 `json:"speed"`
}

func processReader(reader io.Reader, apiKey string) (*geom.Geometry, error) {
    data, err := io.ReadAll(reader)
    if err != nil {
        return nil, fmt.Errorf("error reading data: %s", err)
    }

    cData := C.CBytes(data)
    defer C.free(unsafe.Pointer(cData))
    cLength := C.size_t(len(data))
    cApiKey := C.CString(apiKey)
    defer C.free(unsafe.Pointer(cApiKey))

    geojsonPtr := C.get_geojson_string_from_bytes((*C.uchar)(unsafe.Pointer(cData)), cLength, cApiKey)
    if geojsonPtr == nil {
        errPtr := C.get_last_error()
        errStr := C.GoString(errPtr)
        C.c_api_free_string(errPtr)
        return nil, fmt.Errorf("failed to get GeoJSON: %s", errStr)
    }
    defer C.c_api_free_string(geojsonPtr)

    geojsonStr := C.GoString(geojsonPtr)

    var geojson GeoJSON
    err = json.Unmarshal([]byte(geojsonStr), &geojson)
    if err != nil {
        return nil, fmt.Errorf("error parsing GeoJSON: %s", err)
    }
}
```

NB: This Readme is an explanation of the automation process of creating a C-compatible interface of the RUST library for use by other languages.

lib.rs and c_api.rs:
Both files contribute to the public API that will be exposed in the C header file. The key is that both files are part of the same crate (library).

lib.rs: Contains the core functionality and exposes get_geojson_string_from_bytes and get_geojson_string functions..
c_api.rs: Contains additional FFI-compatible functions.

cbindgen.toml:
This configuration file plays a crucial role in tying everything together. It specifies which functions should be included in the generated header file.

[export]
include = [
"get_geojson_string",
"get_geojson_string_from_bytes",
"parse_dji_log",
"get_last_error",
"c_api_free_string"
]
This tells cbindgen to include these specific functions in the header file, regardless of which Rust file they're defined in.

build.rs:
This script generates the C header file. It uses cbindgen to scan your entire crate (including both lib.rs and c_api.rs) and generate the C bindings based on the configuration in cbindgen.toml.
The key line is:
.with_crate(crate_dir)
This tells cbindgen to look at the entire crate, not just a single file.

Resulting Header File:
The generated dji-log-parser.h will include function declarations for all the functions specified in the cbindgen.toml file, regardless of whether they were defined in lib.rs or c_api.rs.

The build.rs automates the process of creating a C-compatible interface for the RUST library. It ensures that the header
file always matches the actual implementation in the RUST code, in order to reduce the chance of compile error from manual
updates.

To use the RUST library ("libdji_log_parser.a") from other languages, include the generated dji-log-parser.h and link against library.

1: dji-log-parser/dji-log-parser/Cargo.toml (shared for all architectures with target-specific sections):

        [package]
        name = "dji-log-parser"
        version.workspace = true
        authors.workspace = true
        edition = "2021"
        description = "Library for parsing DJI txt logs"
        repository.workspace = true
        license.workspace = true
        keywords.workspace = true
        categories.workspace = true
        rust-version = "1.56"

        [dependencies]
        aes.workspace = true
        base64.workspace = true
        binrw.workspace = true
        cbc.workspace = true
        chrono = { workspace = true, features = ["serde"] }
        crc64.workspace = true
        serde = { workspace = true, features = ["derive"] }
        serde_json.workspace = true
        thiserror.workspace = true
        ureq = { workspace = true, features = ["json"] }
        log = "0.4"
        geojson.workspace = true
        once_cell = "1.8.0"
        libc = "0.2"

        [lib]
        name = "dji_log_parser"
        crate-type = ["staticlib", "rlib"]

        [build-dependencies]
        cbindgen = "0.24.0"
        cc = "1.0"

        [target.'cfg(target_os = "linux")'.dependencies]
        openssl = { version = "0.10", features = ["vendored"] }

        [target.'cfg(target_os = "macos")'.build-dependencies]
        cc = "1.0"

2: build.rs (shared for all architectures):

        use std::env;
        use std::path::PathBuf;

        fn main() {
            if cfg!(target_os = "linux") {
                println!("cargo:rustc-link-lib=m");
            }
            let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
            let package_name = env::var("CARGO_PKG_NAME").unwrap();
            let output_file = PathBuf::from(&crate_dir)
                .join("include")
                .join(format!("{}.h", package_name));

            let config = cbindgen::Config::from_file("cbindgen.toml")
                .expect("Unable to find cbindgen.toml configuration file");

            cbindgen::Builder::new()
                .with_crate(crate_dir)
                .with_config(config)
                .generate()
                .expect("Unable to generate bindings")
                .write_to_file(output_file);
        }

3: Dockerfiles for each architecture:

         a: aarch64-apple-darwin (M1/M2 Mac):

                    FROM --platform=linux/arm64 rust:latest

                    RUN rustup target add aarch64-apple-darwin

                    WORKDIR /usr/src/myapp
                    COPY . .

                    CMD ["cargo", "build", "--release", "--target", "aarch64-apple-darwin"]


         b: x86_64-apple-darwin (Intel Mac):

                    FROM --platform=linux/amd64 rust:latest

                    RUN rustup target add x86_64-apple-darwin

                    WORKDIR /usr/src/myapp
                    COPY . .

                    CMD ["cargo", "build", "--release", "--target", "x86_64-apple-darwin"]



        c. aarch64-unknown-linux-gnu:

                    FROM --platform=linux/arm64 rust:latest

                    RUN apt-get update && apt-get install -y \
                        gcc-aarch64-linux-gnu \
                        g++-aarch64-linux-gnu \
                        libc6-dev-arm64-cross

                    RUN rustup target add aarch64-unknown-linux-gnu

                    ENV CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
                    ENV CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
                    ENV CXX_aarch64_unknown_linux_gnu=aarch64-linux-gnu-g++

                    WORKDIR /usr/src/myapp
                    COPY . .

                    CMD ["cargo", "build", "--release", "--target", "aarch64-unknown-linux-gnu"]


        d. x86_64-unknown-linux-gnu:

                    FROM --platform=linux/amd64 rust:latest

                    RUN rustup target add x86_64-unknown-linux-gnu

                    WORKDIR /usr/src/myapp
                    COPY . .

                    CMD ["cargo", "build", "--release", "--target", "x86_64-unknown-linux-gnu"]

These configurations allow you to build the Rust library for all four target architectures. The Cargo.toml and build.rs files are shared across all targets, with conditional compilation and linking handled within them. The Dockerfiles are specific to each target architecture, setting up the appropriate environment and build commands.
Please note: building for macOS targets (aarch64-apple-darwin and x86_64-apple-darwin) from a Linux-based Docker container might not be possible due to macOS-specific dependencies. In practice, you typically build these on a macOS host directly.

Cross compilation tools were needed to be installed on my macOS, this is an explanation of what was installed and why:

The brew install commands I needed are related to setting up cross-compilation tools on macOS. These tools allow us to compile code for different target architectures from my macOS development environment. Here's a breakdown of the key installations and their purposes:

brew install x86_64-elf-gcc
Purpose: This installs the GNU Compiler Collection (GCC) toolchain for x86_64 ELF (Executable and Linkable Format) targets.
Use: It's used for cross-compiling to 64-bit x86 Linux systems from macOS.

brew install FiloSottile/musl-cross/musl-cross
Purpose: This installs the musl-cross toolchain, which allows cross-compilation to Linux using the musl libc instead of glibc.
Use: It's used for creating statically linked Linux binaries, which can run on virtually any Linux system without dependency issues.

brew install FiloSottile/musl-cross/x86_64-linux-musl-gcc
Purpose: This installs a specific GCC toolchain for compiling to x86_64 Linux with musl libc.
Use: It's used for creating statically linked Linux binaries for x86_64 architecture.

brew install SergioBenitez/osxct/x86_64-unknown-linux-gnu
Purpose: This installs a cross-compilation toolchain for the x86_64-unknown-linux-gnu target.
Use: It allows compiling Rust code for 64-bit Linux systems from macOS.

These installations were necessary because:

Cross-compilation:
I needed to build the Rust library for different target architectures (x86_64 and aarch64) and operating systems (macOS and Linux) from a single macOS development environment.

Static linking:
For the Linux targets, I wanted to create statically linked libraries to avoid dependency issues on the target systems.

Rust and Go integration:
The project Rust library is intended to be called from Go code, which requires proper cross-compilation setup to ensure the Rust library can be linked correctly in different environments.

CI/CD compatibility:
These tools allow us to build for various targets locally, mimicking what might happen in a CI/CD pipeline, ensuring the build process works consistently across different environments.

By installing these tools, we set up a comprehensive cross-compilation environment on macOS, allowing us to build the project for multiple target architectures and operating systems, which was crucial for solving the linking issues in Go, specifically for its use in the Flight-Management repo and ensuring the Rust project could be built and run on various platforms.

For further questions contact Edan Cain.
